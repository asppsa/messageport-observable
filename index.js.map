{"version":3,"file":"index.js","sources":["index.mjs"],"sourcesContent":["import stampit from '@stamp/it';\nimport Observable from 'zen-observable';\n\n/**\n * This is a \"lightweight\" (is it?) wrapper around MessagePort / Window / Worker\n * objects (things that have a postMessage method).\n */\n\n/**\n * This is used to ensure that when the wrapped object is set, method bindings\n * happen\n */\nconst wrapper = stampit()\n  .props({ isWrapped: true })\n  .propertyDescriptors({\n    wrapped: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        return null;\n      },\n      set(obj) {\n        if (!obj)\n          throw new Error(\"Cannot set wrapped object to falsy\");\n\n        delete this.wrapped;\n        Object.defineProperty(this, 'wrapped', {\n          value: obj,\n          writable: true,\n          configurable: true,\n          enumerable: true\n        });\n      }\n    }\n  })\n  .init(function(_, { instance, stamp }) {\n    instance.wrapper = stamp;\n  })\n  .methods({\n    unwrap() {\n      if (!this.wrapped)\n        throw new Error(\"No wrapped object in this wrapper\");\n\n      return this.wrapped.isWrapped ? this.wrapped.unwrap() : this.wrapped;\n    }\n  });\n\nfunction filteringPropertyDescriptor(type) {\n  const attribute = 'on' + type;\n\n  return {\n    enumerable: true,\n    configurable: false,\n    get() {\n      return this.wrapped[attribute];\n    },\n    set(listener) {\n      const eventFilter = this.eventFilters[type];\n      if (eventFilter) {\n        this.wrapped[attribute] = function(event) {\n          if (eventFilter.call(this, event))\n            listener.call(this, event);\n        };\n      }\n      else {\n        this.wrapped[attribute] = listener;\n      }\n    }\n  };\n}\n\n// Use a WeakMap if poss.  That way, if the messageport loses the ref to\n// the listener on its own, there's no memory leak\nconst mapImpl = typeof WeakMap === 'function' ? WeakMap : Map;\n\n/**\n * This is stamp returns an object that wraps event handlers so that they only\n * fire when the given filters apply\n */\nconst filteringPort = wrapper\n  .init(function(_, { instance, stamp }) {\n    instance.eventFilters = {};\n    instance.eventListeners = {};\n  })\n  .methods({\n    filter() {\n      let newFilter, type;\n\n      if (arguments.length === 1) {\n        type = 'message';\n        newFilter = arguments[0];\n      }\n      else {\n        type = arguments[0];\n        newFilter = arguments[1];\n      }\n\n      const clone = this.wrapper(this);\n      clone.autostart = false;\n      clone.eventFilters[type] = newFilter;\n\n      return clone;\n    },\n\n    addEventListener(type, listener, options) {\n      if (!this.eventListeners[type])\n        this.eventListeners[type] = new mapImpl();\n\n      // This ensures that we are only notified about events that haven't been\n      // filtered out\n      if (!this.eventListeners[type].has(listener)) {\n        const eventFilter = this.eventFilters[type];\n\n        let wrappedListener;\n        if (eventFilter) {\n          wrappedListener = function(event) {\n            if (eventFilter(event)) {\n              typeof listener.handleEvent === 'function' ?\n                listener.handleEvent(event) :\n                listener(event);\n            }\n          };\n        }\n        else {\n          wrappedListener = listener;\n        }\n\n        this.wrapped.addEventListener(type, wrappedListener, options);\n        this.eventListeners[type].set(listener, wrappedListener);\n      }\n    },\n\n    removeEventListener(type, listener, options) {\n      if (this.eventListeners[type] && this.eventListeners[type].has(listener)) {\n        this.wrapped.removeEventListener(type, this.eventListeners[type].get(listener), options);\n        this.eventListeners[type].delete(listener);\n      }\n    }\n  })\n  .propertyDescriptors({\n    onmessage: filteringPropertyDescriptor('message'),\n    onmessageerror: filteringPropertyDescriptor('messageerror')\n  });\n\nconst observablePort = stampit()\n  .props({\n    autostart: true\n  })\n  .init(function(_, { instance }) {\n    // Add standardised observable accessor, if poss.\n    if (typeof Symbol === 'function' && Symbol.observable)\n      instance[Symbol.observable] = () => instance.observable;\n  })\n  .propertyDescriptors({\n    observable: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        const observable = new Observable(observer => {\n          const messageCb = observer.next.bind(observer);\n          const messageErrorCb = observer.error.bind(observer);\n          this.addEventListener('message', messageCb);\n          this.addEventListener('messageerror', messageErrorCb);\n\n          if (this.autostart && this.start)\n            this.start();\n\n          return () => {\n            this.removeEventListener('message', messageCb);\n            this.removeEventListener('messageerror', messageErrorCb);\n          };\n        });\n\n        delete this.observable;\n        Object.defineProperty(this, 'observable', {\n          value: observable,\n          writable: true,\n          configurable: true,\n          enumerable: true\n        });\n\n        return observable;\n      }\n    }\n  })\n  .methods({\n    subscribe(...args) {\n      return this.observable.subscribe(...args);\n    },\n\n    postMessageWithReply(message, listener) {\n      const messageChannel = new MessageChannel(),\n        replyPort = this.wrapper(messageChannel.port1);\n\n      this.postMessage(message, [messageChannel.port2]);\n      if (listener)\n        listener(replyPort);\n      else\n        return replyPort;\n    },\n\n    postObservable(observable, splat = false, close = false) {\n      const complete = close && typeof this.close === 'function' ?\n        () => this.close() :\n        undefined;\n\n      const next = splat ?\n        (args) => this.postMessage(...args) :\n        this.postMessage.bind(this);\n\n      return Observable.from(observable).subscribe(next, complete, complete);\n    },\n\n    postMessageWithObservable(message, observable, splat=false) {\n      const messageChannel = new MessageChannel(),\n        postPort = this.wrapper(messageChannel.port1);\n\n      this.postMessage(message, [messageChannel.port2]);\n      return postPort.postObservable(observable, splat, true);\n    },\n\n    subscribeWithPort(listener, splat=false) {\n      const wrapper = this.wrapper;\n      return this.subscribe(event => {\n        const port = event.ports[0];\n        const wrappedPort = port ? wrapper(port) : null;\n        listener(event, wrappedPort);\n      });\n    },\n\n    subscribeAndPostReplies(listener, splat = false) {\n      return this.subscribeWithPort((event, replyPort) => {\n        const response = listener(event);\n        if (response && replyPort)\n          replyPort.postObservable(response, splat, true);\n      }, splat);\n    }\n  });\n\nconst filteringObservablePort = filteringPort.compose(observablePort);\n\n/**\n * A generic wrapper around MessagePort objects (incl. workers)\n */\nconst wrapPort = filteringObservablePort\n  .init(function(port, { instance }) {\n    if (!port)\n      throw new Error(\"No port given\");\n\n    instance.wrapped = port;\n    for (let method of ['postMessage', 'start', 'close']) {\n      if (typeof port[method] === 'function')\n        instance[method] = port[method].bind(port);\n    }\n  });\n\n/**\n * A MessagePort-alike interface for windows.  Adds the following:\n *\n * - filters to ensure that all events sent and received have an origin setting.\n * - shims the postMessage method so that it looks like the MessagePort one\n */\nconst wrapWindow = filteringObservablePort\n  .init(function(options, { instance }) {\n    if (!options.window)\n      throw new Error(\"No window given\");\n\n    if (!options.origin || options.origin === \"\")\n      throw new Error(\"No origin given\");\n\n    // Override the wrapper variable so that subsequently created ports don't\n    // use this constructor.  This can be provided as a parameter if you want to\n    // compose in some stuff.\n    instance.wrapper = options.wrapPort ? options.wrapPort : wrapPort;\n\n    instance.wrapped = options.window;\n    instance.origin = options.origin;\n\n    // Set up initial filters if a specific origin is given.\n    if (instance.origin !== '*') {\n      instance.eventFilters['message'] = instance.eventFilters['messageerror'] =\n        event => event.origin === options.origin;\n    }\n  })\n  .methods({\n    // Provide a compliant postMessage\n    postMessage(message, transferList) {\n      this.wrapped.postMessage(message, this.origin, transferList);\n    }\n  });\n\nexport { wrapPort, wrapWindow };\n"],"names":["wrapper","stampit","props","isWrapped","propertyDescriptors","obj","Error","wrapped","defineProperty","init","_","instance","stamp","methods","unwrap","filteringPropertyDescriptor","type","attribute","listener","eventFilter","eventFilters","event","call","mapImpl","WeakMap","Map","filteringPort","eventListeners","newFilter","arguments","length","clone","autostart","options","has","wrappedListener","handleEvent","addEventListener","set","removeEventListener","get","delete","observablePort","Symbol","observable","Observable","messageCb","observer","next","bind","messageErrorCb","error","start","subscribe","message","messageChannel","MessageChannel","replyPort","port1","postMessage","port2","splat","close","complete","undefined","args","from","postPort","postObservable","port","ports","wrappedPort","subscribeWithPort","response","filteringObservablePort","compose","wrapPort","method","wrapWindow","window","origin","transferList"],"mappings":"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"}